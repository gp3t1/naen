#!/bin/bash
#set -x

DATE=$(date +%H%M%S)
TMP_DIR=/tmp/nginx/tmp
CFG_DIR=/etc/nginx/conf.d
CFG_FILE=$CFG_DIR/nginx.conf
mkdir -p "$TMP_DIR"

tmp_upstreams=$TMP_DIR/upstreams.$DATE
tmp_locations=$TMP_DIR/locations.$DATE
tmp_domain=$TMP_DIR/domain.$DATE

if [[ $# -lt 2 ]]; then
	echo "usage: $0 <mondomain.xyz> <UpstreamName>=/<PublicUri>><UpstreamSrv>:<UpstreamPort>/<UpstreamUri>"
	#"gp3t1.xyz" "commafeed=/rss>naen-commafeed:8082/"
	exit 1
fi

function gen_upstream {
	[[ $# -ne 3 ]] && return 1
	UPSTREAM=$1
	APP_HOST=$2
	APP_PORT=$3
	echo "append to $tmp_upstreams"
	cat >> "$tmp_upstreams" <<-EOF
		upstream ${UPSTREAM} {
		    server ${APP_HOST}:${APP_PORT};
		  }

	EOF
	[[ -f $tmp_upstreams ]]
}

function gen_location {
	[[ $# -lt 2 || $# -gt 3 ]] && return 1
	UPSTREAM=$1
	PUB_URI=$2
	APP_URI=$3
	echo "append to $tmp_locations"
	cat >> "$tmp_locations" <<-EOF
		location = ${PUB_URI} {
		      return 301 https://\$host\$request_uri/;
		    }
		    location ~ ^${PUB_URI}/(.*)\$ {
		      rewrite ${PUB_URI}/(.*) ${APP_URI}/\$1  break;
		      proxy_pass http://${UPSTREAM};
		      proxy_redirect off;
		      proxy_set_header Accept-Encoding "";
		      proxy_set_header X-Forwarded-Proto \$scheme;
		      proxy_set_header X-Real-IP  \$remote_addr;
		      #proxy_set_header X-Forwarded-For \$remote_addr;
		      proxy_set_header X-Forwarded-For \$proxy_add_x_forwarded_for;
		      proxy_set_header Host \$host;
		      add_header Front-End-Https on;
		    }

	EOF
	[[ -f $tmp_locations ]]
} 

function gen_domain {
	[[ $# -ne 1 ]] && return 1
	[[ ! -f "$tmp_upstreams" || ! -f "$tmp_locations" ]] && echo "can't find temporary upstreams and locations!" && exit 1
	DOMAIN=$1
	echo "append to $tmp_domain"
	cat > "$tmp_domain" <<-EOF
		#### Domain Configuration for ${DOMAIN}

		  $( cat "$tmp_upstreams" )		  

		  server {
		    listen 80;
		    server_name ${DOMAIN};
		    location / {
		      return 301 https://\$host\$request_uri;
		    }
		  }

		  server {
		    listen 443 ssl http2;
		    server_name ${DOMAIN};
		    #root /usr/share/nginx/html;
		    #index index.html;

		    access_log /var/log/nginx/${DOMAIN}-access.log combined buffer=16k;
		    error_log  /var/log/nginx/${DOMAIN}-error.log  warn;

		    # certs sent to the client in SERVER HELLO are concatenated in ssl_certificate
		    ssl_certificate     /etc/letsencrypt/live/${DOMAIN}/fullchain.pem;
		    ssl_certificate_key /etc/letsencrypt/live/${DOMAIN}/privkey.pem;

		    # Turn on session resumption, using a 10 min cache shared across nginx processes, as recommended by http://nginx.org/en/docs/http/configuring_https_servers.html
		    ssl_session_timeout 10m;
		    ssl_session_cache shared:SSL:10m;
		    ssl_session_tickets off;

		    # timeout during which a keep-alive client connection will stay open.
		    keepalive_timeout   70;

		    # Diffie-Hellman parameter for DHE ciphersuites, recommended 2048 bits
		    # Generate with: openssl dhparam -out /etc/nginx/conf.d/dhparam.pem 2048
		    ssl_dhparam /etc/nginx/conf.d/dhparam.pem;

		    # intermediate configuration. tweak to your needs.
		    ssl_protocols TLSv1 TLSv1.1 TLSv1.2;
		    ssl_prefer_server_ciphers on;
		    ssl_ciphers 'ECDHE-RSA-AES128-GCM-SHA256:ECDHE-ECDSA-AES128-GCM-SHA256:ECDHE-RSA-AES256-GCM-SHA384:ECDHE-ECDSA-AES256-GCM-SHA384:DHE-RSA-AES128-GCM-SHA256:DHE-DSS-AES128-GCM-SHA256:kEDH+AESGCM:ECDHE-RSA-AES128-SHA256:ECDHE-ECDSA-AES128-SHA256:ECDHE-RSA-AES128-SHA:ECDHE-ECDSA-AES128-SHA:ECDHE-RSA-AES256-SHA384:ECDHE-ECDSA-AES256-SHA384:ECDHE-RSA-AES256-SHA:ECDHE-ECDSA-AES256-SHA:DHE-RSA-AES128-SHA256:DHE-RSA-AES128-SHA:DHE-DSS-AES128-SHA256:DHE-RSA-AES256-SHA256:DHE-DSS-AES256-SHA:DHE-RSA-AES256-SHA:ECDHE-RSA-DES-CBC3-SHA:ECDHE-ECDSA-DES-CBC3-SHA:AES128-GCM-SHA256:AES256-GCM-SHA384:AES128-SHA256:AES256-SHA256:AES128-SHA:AES256-SHA:AES:CAMELLIA:DES-CBC3-SHA:!aNULL:!eNULL:!EXPORT:!DES:!RC4:!MD5:!PSK:!aECDH:!EDH-DSS-DES-CBC3-SHA:!EDH-RSA-DES-CBC3-SHA:!KRB5-DES-CBC3-SHA';

		    # HSTS (ngx_http_headers_module is required) (15768000 seconds = 6 months)
		    ## HTTP Strict Transport Security: tells browsers to require https:// without first checking
		    ## the http:// version for a redirect. Warning: it is difficult to change your mind.
		    ## 
		    ##    max-age: length of requirement in seconds (31536000 = 1 year)
		    ##    includeSubdomains: force TLS for *ALL* subdomains (remove if this is not what you want)
		    ##    preload: indicates you want browsers to ship with HSTS preloaded for your domain.
		    ## 
		    ##    Submit your domain for preloading in browsers at: https://hstspreload.appspot.com
		    # add_header Strict-Transport-Security 'max-age=31536000; includeSubDomains; preload';
		    ##    If you won't/can't turn on HTTPS for *all* subdomains, use this simpler version:
		    # add_header Strict-Transport-Security 'max-age=31536000';
		    add_header Strict-Transport-Security 'max-age=31536000';

		    # OCSP Stapling ---
		    # fetch OCSP records from URL in ssl_certificate and cache them
		    ssl_stapling on;
		    ssl_stapling_verify on;
		    ## verify chain of trust of OCSP response using Root CA and Intermediate certs
		    ssl_trusted_certificate /etc/letsencrypt/live/${DOMAIN}/chain.pem;

		    # If you want to specify a DNS resolver for stapling, you can uncomment the below
		    # line. If you leave it commented, nginx will use your system resolver, which will probably
		    # work just fine!
		    # resolver <IP DNS resolver>;

		    #### Locations for ${DOMAIN}
		    $( cat "$tmp_locations" )

		  }
	EOF
	[[ -f $tmp_domain ]]
}

function write_config {
	[[ ! -f "$tmp_domain" ]] && echo "can't find temporary domain!" && exit 1
	mv "$CFG_FILE" "$CFG_FILE.$DATE"
	echo "append to $CFG_FILE"
	cat > "$CFG_FILE" <<-EOF
	user nginx;
	worker_processes 1;
	pid /var/run/nginx/pid;
	
	events {
	  worker_connections  1024;
	  # worker_processes and worker_connections allows you to calculate maxclients value: max_clients = worker_processes * worker_connections
	}

	http {
	  # anything written in /etc/nginx/mime.types is interpreted as if written inside the http { } block
	  include /etc/nginx/conf.d/mime.types;
	  default_type application/octet-stream;
	  #log_format  main  '\$remote_addr - \$remote_user [\$time_local] "\$request" '
	  #                  '\$status \$body_bytes_sent "\$http_referer" '
	  #                  '"\$http_user_agent" "\$http_x_forwarded_for"';
	  error_log /var/log/nginx/error.log warn;

	  # If serving locally stored static files, sendfile is essential to speed up the server, but if using as reverse proxy one can deactivate it
	  sendfile        off;

	  location ~ /\.ht {
	    deny all;
	  }

	  $( cat "$tmp_domain" )
	}
	EOF
	if [[ -f "$CFG_FILE" && $( gosu nginx nginx -t -c "${CFG_FILE}" -g "daemon off;" ) ]] ; then
		echo "Nginx configured and tested!"
		exit 0
	else
		echo "Nginx config failed!"
		exit 1
	fi
}

function main {

	domain=$1
	shift
	while [[ -n $1 ]]; do
		upstream=$( echo "$1" | awk -F "=" '{ print $1 }')
		app_host=$( echo "$1" | awk -F "=" '{ print $2 }' | awk -F ">" '{ print $2 }' | awk -F ":" '{ print $1 }')
		app_port=$( echo "$1" | awk -F "=" '{ print $2 }' | awk -F ">" '{ print $2 }' | awk -F ":" '{ print $2 }' | awk -F "/" '{ print $1 }')
		pub_uri=$(  echo "$1" | awk -F "=" '{ print $2 }' | awk -F ">" '{ print $1 }')
		app_uri=/$( echo "$1" | awk -F "=" '{ print $2 }' | awk -F ">" '{ print $2 }' | awk -F ":" '{ print $2 }' | awk -F "/" '{ print $2 }')
		# normalize uris
		[[ $pub_uri =~ ^/ ]] || pub_uri="/$pub_uri"
		[[ $pub_uri =~ ^/.*/$ ]] && pub_uri=${pub_uri%%/}
		[[ $app_uri =~ ^/ ]] || app_uri="/$app_uri"
		[[ $app_uri =~ ^.*/$ ]] && app_uri=${app_uri%%/}

		if ! gen_upstream "$upstream" "$app_host" "$app_port"; then
			echo "Error generating upstream $upstream"
			exit 1
		else
			if ! gen_location "$upstream" "$pub_uri" "$app_uri"; then
				echo "Error generating location $pub_uri"
				exit 1
			fi
		fi
		shift
	done
	
	gen_domain "$domain"
	
	write_config
}

main "$@"
